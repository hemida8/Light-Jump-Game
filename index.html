<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>القفزة الضوئية: النهضة الكاملة</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --bg-grad-1: #0c001f;
            --bg-grad-2: #1c0f3a;
            --glow-color: #8e2de2;
        }
        body {
            margin: 0; padding: 0;
            color: #fff; font-family: 'Cairo', sans-serif;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; height: 100vh;
            overflow: hidden; text-align: center;
            background: linear-gradient(160deg, var(--bg-grad-1), var(--bg-grad-2));
            transition: background 2s ease;
        }
        .hidden { display: none !important; }
        #background-stars {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><defs><pattern id="p" width="300" height="300" patternUnits="userSpaceOnUse"><circle cx="50" cy="50" r="1" fill="%23fff" opacity="0.8"></circle><circle cx="150" cy="200" r="1.5" fill="%23fff" opacity="0.6"></circle><circle cx="250" cy="100" r="0.5" fill="%23fff" opacity="0.9"></circle></pattern></defs><rect width="100%" height="100%" fill="url(%23p)"></rect></svg>');
            z-index: -2;
            animation: move-stars 120s linear infinite;
        }
        @keyframes move-stars {
            from { background-position: 0 0; }
            to { background-position: 300px 300px; }
        }
        canvas {
            display: block; touch-action: none; border-radius: 15px;
            box-shadow: 0 0 40px var(--glow-color), 0 0 80px var(--glow-color);
            transition: box-shadow 2s ease;
            background: transparent;
            z-index: 1;
        }
        .ui-layer {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        #mainMenu {
            z-index: 10;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        #mainMenu h1 {
            font-size: 4rem; font-weight: 900;
            text-shadow: 0 0 10px #fff, 0 0 20px var(--glow-color), 0 0 40px var(--glow-color);
            margin-bottom: 10px;
        }
        #mainMenu p { font-size: 1.2rem; margin-bottom: 40px; color: rgba(255,255,255,0.8); }
        #modeSelector { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; }
        .mode-btn {
            background: transparent; border: 2px solid #fff;
            color: white; padding: 15px 35px;
            text-align: center; font-size: 1.2rem; font-family: 'Cairo', sans-serif;
            border-radius: 50px; cursor: pointer; transition: all 0.3s ease;
        }
        .mode-btn:hover {
            background: var(--glow-color);
            border-color: var(--glow-color);
            transform: translateY(-5px);
            box-shadow: 0 5px 20px var(--glow-color);
        }
        #ui-container {
            pointer-events: none;
            z-index: 5; 
        }
        #gameOverMenu {
            display: none; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(12, 0, 31, 0.8); padding: 40px; border-radius: 20px;
            pointer-events: all; backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: fadeIn 0.5s ease;
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        #gameOverMenu h1 { font-size: 2.8rem; margin: 0; color: #fff; text-shadow: 0 0 15px #fff; }
        #gameOverMenu p { font-size: 1.3rem; margin: 10px 0 25px 0; }
        #gameOverMenu button {
            background: linear-gradient(45deg, #8e2de2, #4a00e0); border: none; color: white; padding: 15px 32px;
            text-align: center; font-size: 1.2rem; font-family: 'Cairo', sans-serif;
            border-radius: 50px; cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #gameOverMenu button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(74, 0, 224, 0.7); }
        #scoreContainer {
            position: absolute; top: 15px; left: 50%;
            transform: translateX(-50%); background: rgba(0, 0, 0, 0.25);
            padding: 8px 20px; border-radius: 20px; display: flex;
            gap: 20px; /* Adjusted gap */
            align-items: center;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 2;
        }
        .scoreText { font-size: 1.2rem; font-weight: bold; text-shadow: 0 0 8px #fff; }
        #scoreMultiplierDisplay {
            font-size: 1.5rem;
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            transition: transform 0.2s ease;
        }
        #timerDisplay { color: #f7b733; }
        #levelDisplay {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); font-size: 2rem; font-weight: bold;
            color: rgba(255,255,255,0.6); transition: all 1s ease;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            z-index: 2;
            opacity: 0; /* Start hidden */
        }

        @media (max-width: 600px) {
            body { padding: 0 !important; }
            #mainMenu h1 { font-size: 2.2rem !important; }
            #mainMenu p { font-size: 1rem !important; }
            .mode-btn { font-size: 1rem !important; padding: 10px 18px !important; }
            #scoreContainer { gap: 10px !important; padding: 4px 8px !important; font-size: 1rem !important; }
            #levelDisplay { font-size: 1.1rem !important; bottom: 10px !important; }
            #gameOverMenu { padding: 15px !important; border-radius: 10px !important; }
            #gameOverMenu h1 { font-size: 1.5rem !important; }
            #gameOverMenu p { font-size: 1rem !important; }
            #gameOverMenu button { font-size: 1rem !important; padding: 10px 18px !important; }
            canvas { border-radius: 8px !important; }
            .scoreText { font-size: 0.85rem !important; padding: 0 2px !important; }
            #scoreMultiplierDisplay { font-size: 1.1rem !important; }
        }
    </style>
</head>
<body>
    <div id="background-stars"></div>

    <div id="mainMenu" class="ui-layer">
        <h1>القفزة الضوئية</h1>
        <p>اختر طور اللعب الذي تفضله</p>
        <div id="modeSelector">
            <button class="mode-btn" data-mode="zen">🧘 طور الاسترخاء</button>
            <button class="mode-btn" data-mode="classic">🚀 الطور الكلاسيكي</button>
            <button class="mode-btn" data-mode="frenzy">👹 طور الجنون</button>
            <button class="mode-btn" data-mode="timeAttack">⏱️ سباق الزمن</button>
        </div>
        <div style="margin-top:32px;">
      <span style="display:inline-block;padding:8px 22px;border-radius:30px;background:linear-gradient(90deg,#8e2de2,#4a00e0);color:#fff;font-weight:900;font-size:1.1rem;box-shadow:0 2px 12px #4a00e055;letter-spacing:1px;">المطور: Mohammed Hemida</span>
    </div>
    </div>

    <div id="scoreContainer" class="hidden">
        <div id="scoreDisplay" class="scoreText">النتيجة: 0</div>
        <div id="highScoreDisplay" class="scoreText">أعلى نتيجة: 0</div>
        <div id="scoreMultiplierDisplay" class="hidden"></div>
        <div id="timerDisplay" class="scoreText hidden">الوقت: 60</div>
    </div>
    <div id="levelDisplay"></div>
    <canvas id="gameCanvas" class="hidden"></canvas>

    <div id="ui-container" class="ui-layer">
        <div id="gameOverMenu">
            <h1>انتهت اللعبة</h1>
            <p id="finalScore">نتيجتك: 0</p>
            <button id="restartButton">العب مرة أخرى</button>
            <button id="mainMenuButton" style="margin-top: 15px; background: transparent; border: 1px solid #fff;">القائمة الرئيسية</button>
        </div>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mainMenu = document.getElementById('mainMenu');
        const scoreContainer = document.getElementById('scoreContainer');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const gameOverMenu = document.getElementById('gameOverMenu'), restartButton = document.getElementById('restartButton'), mainMenuButton = document.getElementById('mainMenuButton'),
              finalScoreDisplay = document.getElementById('finalScore'), scoreDisplay = document.getElementById('scoreDisplay'),
              highScoreDisplay = document.getElementById('highScoreDisplay'), levelDisplay = document.getElementById('levelDisplay'), timerDisplay = document.getElementById('timerDisplay'),
              scoreMultiplierDisplay = document.getElementById('scoreMultiplierDisplay');
        
        // --- Audio Engine (Tone.js) ---
        let audioReady = false;
        const sounds = {};

        function initAudio() {
            if (audioReady) return;
            Tone.start();

            // مؤثرات خفيفة فقط للأصوات المهمة
            const reverb = new Tone.Reverb({ decay: 1.2, preDelay: 0.04, wet: 0.18 }).toDestination();

            // أصوات ناعمة وبسيطة
            sounds.jump = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.08, sustain: 0.1, release: 0.12 }
            }).connect(reverb);

            sounds.bouncyJump = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.09, sustain: 0.08, release: 0.13 }
            }).connect(reverb);

            sounds.superJump = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.18, sustain: 0.1, release: 0.18 }
            }).connect(reverb);

            sounds.breakPlatform = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.01, decay: 0.13, sustain: 0, release: 0.08 }
            }).connect(reverb);

            sounds.powerup = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.12, sustain: 0.1, release: 0.15 }
            }).connect(reverb);

            sounds.shieldDeflect = new Tone.MetalSynth({
                frequency: 180,
                envelope: { attack: 0.01, decay: 0.13, release: 0.09 },
                harmonicity: 4.1,
                modulationIndex: 20,
                resonance: 2000,
                octaves: 1.2
            }).connect(reverb);

            sounds.gameOver = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.18, sustain: 0.1, release: 0.5 }
            }).connect(reverb);

            sounds.levelUp = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.13, sustain: 0.1, release: 0.18 }
            }).connect(reverb);

            sounds.perfectJump = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.08, sustain: 0.08, release: 0.12 }
            }).connect(reverb);

            sounds.surprise = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }
            }).connect(reverb);

            sounds.platformMove = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.08, sustain: 0.05, release: 0.09 }
            }).connect(reverb);

            // صوت اختيار القائمة
            sounds.menuSelect = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.07, sustain: 0.05, release: 0.08 }
            }).connect(reverb);

            // صوت الجوهرة: نغمة قصيرة فقط
            sounds.scoreBoost = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.09, sustain: 0.05, release: 0.09 }
            }).connect(reverb);

            sounds.phase = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.09, sustain: 0.05, release: 0.09 }
            }).connect(reverb);

            sounds.rumble = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 1.2,
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.13, sustain: 0.05, release: 0.13 }
            }).connect(reverb);

            audioReady = true;
        }
        
        function playSound(soundName, note, time) {
            if (!audioReady || !sounds[soundName]) return;
            try {
                sounds[soundName].triggerAttackRelease(note, "8n", time);
            } catch (e) {
                console.error(`Error playing sound ${soundName}:`, e);
            }
        }
        
        document.body.addEventListener('click', initAudio, { once: true });
        document.body.addEventListener('touchstart', initAudio, { once: true });

        // --- Game State ---
        let canvasWidth, canvasHeight, score, highScore, gameOver, particles, platforms, bombs, powerups, cameraY, currentLevelIndex, selectedMode, gameTimer;
        let screenShake = { intensity: 0, duration: 0 };
        let lastBombSpawnScore = 0;
        let animationFrameId;
        let lastTime = 0;
        let frenzyShake = { timer: 0, interval: 180 };
        let dynamicSpeedMultiplier = 1;
        let scoreMultiplier = { active: false, timer: 0 };

        // --- تحسينات ديناميكية ---
        let suddenMovingPlatforms = [];
let surpriseEvents = [];
let perfectStreak = 0;
let lastPerfectTime = 0;

// --- عداد نافذة superJump ---
const SUPERJUMP_WINDOW = 600; // نافذة نقاط
const SUPERJUMP_MAX_PER_WINDOW = 2; // أقصى عدد مرات ظهور في النافذة
let superJumpWindowStartScore = 0;
let superJumpAppearancesInWindow = 0;

        const modeSettings = {
            zen:        { gravity: 0.6,  jumpPower: 22, bombSpawnRate: 0,      speedMod: 1.0, powerupRate: 0.03,  platWidthMod: 25 },
            classic:    { gravity: 0.75, jumpPower: 22, bombSpawnRate: 0.008,  speedMod: 1.3, powerupRate: 0.02,  platWidthMod: 0 },
            frenzy:     { gravity: 0.95, jumpPower: 23, bombSpawnRate: 0.015,  speedMod: 1.8, powerupRate: 0.015, platWidthMod: -25 },
            timeAttack: { gravity: 0.7,  jumpPower: 22, bombSpawnRate: 0.01,   speedMod: 1.4, powerupRate: 0.035, platWidthMod: 10 }
        };

        const baseLevels = [
            { score: 0,     name: "بداية الفجر",     bg: ["#0c001f", "#1c0f3a"], glow: "#8e2de2", platformSpeed: 2.0 },
            { score: 1000,  name: "الشفق النيلي",    bg: ["#1a1a4a", "#2a0845"], glow: "#00c6ff", platformSpeed: 2.4 },
            { score: 3000,  name: "السديم الأخضر",   bg: ["#0f3a3f", "#1d6c5a"], glow: "#a8e063", platformSpeed: 2.8 },
            { score: 6000,  name: "العاصفة القرمزية", bg: ["#4f1b2a", "#8c2c4b"], glow: "#ff416c", platformSpeed: 3.2 },
            { score: 10000, name: "الفضاء الذهبي",   bg: ["#5c401b", "#a7712b"], glow: "#f7b733", platformSpeed: 3.6 },
            { score: 15000, name: "القلب المجري",    bg: ["#4e145f", "#1d0c4d"], glow: "#e040fb", platformSpeed: 4.0 }
        ];

        let dynamicLevels = [];

        const player = { x: 0, y: 0, width: 20, height: 20, dy: 0, jumpPower: 22, gravity: 0.7, squash: 1, hasShield: false, shieldRadius: 30, trail: [] };
        
        function resizeCanvas() {
            // اجعل العرض يتناسب مع الشاشة الصغيرة
            const isMobile = window.innerWidth < 600;
            canvasWidth = isMobile ? window.innerWidth - 10 : Math.min(800, window.innerWidth - 30);
            canvasHeight = isMobile ? window.innerHeight * 0.8 : window.innerHeight * 0.9;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            // تكبير النصوص والعناصر للهواتف
            document.body.style.fontSize = isMobile ? '1.1rem' : '';
            document.getElementById('mainMenu').style.padding = isMobile ? '10px' : '';
            document.getElementById('scoreContainer').style.fontSize = isMobile ? '1.1rem' : '';
            document.getElementById('levelDisplay').style.fontSize = isMobile ? '1.2rem' : '';
        }

        function startGame() {
            initAudio(); 
            gameOver = false; score = 0; cameraY = 0; currentLevelIndex = 0; lastBombSpawnScore = 0;
            platforms = []; bombs = []; particles = []; powerups = [];
            player.hasShield = false; player.trail = [];
            dynamicLevels = JSON.parse(JSON.stringify(baseLevels)); // Deep copy to prevent mutation issues
            frenzyShake.timer = frenzyShake.interval; 
            scoreMultiplier = { active: false, timer: 0 };
            
            const mode = modeSettings[selectedMode];
            player.gravity = mode.gravity;
            player.jumpPower = mode.jumpPower;
            highScore = localStorage.getItem(`luminousLeapHighScore_${selectedMode}`) || 0;
            
            if (selectedMode === 'timeAttack') {
                gameTimer = 60;
                timerDisplay.classList.remove('hidden');
            } else {
                timerDisplay.classList.add('hidden');
            }
            
            updateLevel(true);
            gameOverMenu.style.display = 'none';

            const startPlatform = { x: canvasWidth / 2 - 60, y: canvasHeight - 50, width: 120 + mode.platWidthMod, height: 20, type: 'normal' };
            platforms.push(startPlatform);
            player.x = startPlatform.x + startPlatform.width / 2 - player.width / 2;
            player.y = startPlatform.y - player.height;
            player.dy = -player.jumpPower;
            
            let lastY = startPlatform.y;
            for (let i = 0; i < 15; i++) {
                lastY -= (95 + Math.random() * 50);
                let newX = Math.random() * (canvasWidth - (120 + mode.platWidthMod));
                platforms.push(createPlatform(newX, lastY));
            }

            updateScoreUI();
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            lastTime = 0; 
            gameLoop();
        }

        function gameLoop(timestamp) {
            if (gameOver) {
                showGameOverMenu();
                return;
            }

            let deltaTime = (timestamp - lastTime) / 1000;
            if(!lastTime || deltaTime > 1) deltaTime = 1/60; 
            lastTime = timestamp;

            update(deltaTime);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            dynamicSpeedMultiplier = 0.8 + (score / 5000) * 0.12; // Reduced initial speed and acceleration
            dynamicSpeedMultiplier = Math.min(dynamicSpeedMultiplier, 2.0); // Added speed limit
            enhancePlatformGeneration();
            
            if (selectedMode === 'timeAttack') {
                gameTimer -= deltaTime;
                if (gameTimer <= 0) {
                    gameTimer = 0;
                    gameOver = true;
                    playSound('gameOver', 'C2');
                }
            }

            if (selectedMode === 'frenzy') {
                frenzyShake.timer--;
                if (frenzyShake.timer <= 0) {
                    triggerScreenShake(12, 40);
                    frenzyShake.timer = 120 + Math.random() * 180;
                    playSound('rumble', 'C1');
                }
            }
            
            if (scoreMultiplier.active) {
                scoreMultiplier.timer -= deltaTime;
                if (scoreMultiplier.timer <= 0) {
                    scoreMultiplier.active = false;
                }
                updateScoreUI();
            }

            player.dy += player.gravity * dynamicSpeedMultiplier;
            player.y += player.dy;
            player.squash = Math.max(1, player.squash - 0.05);
            player.trail.push({x: player.x, y: player.y, width: player.width/player.squash, height: (player.height*player.squash)});
            if (player.trail.length > 20) player.trail.shift();

            if (player.y < cameraY + canvasHeight / 2.5) {
                let diff = (cameraY + canvasHeight / 2.5) - player.y;
                cameraY -= diff; 
if (selectedMode !== 'timeAttack') {
let points = Math.ceil(diff / 100);
                    if (scoreMultiplier.active) {
                        points *= 2;
                    }
                    score += points;
                }
                updateScoreUI();
                updateLevel();
            }

            if (player.dy > 0) {
                platforms.forEach(platform => {
                    if (platform.type === 'phasing' && !platform.isVisible) return;
                    
                    if (player.x + player.width > platform.x && player.x < platform.x + platform.width &&
                        player.y + player.height >= platform.y && (player.y + player.height) - player.dy <= platform.y + 10) {
                        
                        const platformCenter = platform.x + platform.width / 2;
                        const playerCenter = player.x + player.width / 2;
                        if (Math.abs(platformCenter - playerCenter) < platform.width * 0.15) {
                             score += 25 * (scoreMultiplier.active ? 2 : 1);
                             createParticle(playerCenter, platform.y, '#FFD700', 30, 5, 2);
                             playSound('perfectJump', 'C6');
                             // تعزيز الشعور بالمكافأة عند سلسلة قفزات مثالية
                             if (Date.now() - lastPerfectTime > 1200) {
                                perfectStreak = 1;
                            } else {
                                perfectStreak++;
                            }
                            lastPerfectTime = Date.now();
                            // تقليل تكرار المكافآت: لا تمنح مكافأة إضافية إلا كل 3 قفزات مثالية متتالية فقط
                            if (perfectStreak > 1 && perfectStreak % 3 === 0) {
                                createParticle(playerCenter, platform.y, '#00ffea', 40 + perfectStreak*10, 7, 2 + perfectStreak*0.2);
                                playSound('levelUp', ['C5', 'E5', 'G5']);
                                score += 10 * perfectStreak;
                            }
                        }

                        player.y = platform.y - player.height;
                        player.squash = 1.6;
                        
                        let jumpMultiplier = 1;
                        let particleColor = '#ffffff';
                        if (platform.type === 'bouncy') { 
                            jumpMultiplier = 1.7; 
                            particleColor = '#a8e063';
                            playSound('bouncyJump', 'C5');
                        } else {
                            playSound('jump', 'C4');
                        }
                        player.dy = -player.jumpPower * jumpMultiplier;

                        if (platform.type === 'breaking' && !platform.isBreaking) {
                            platform.isBreaking = true;
                            particleColor = '#ff416c';
                            playSound('breakPlatform', null);
                        }
                        createParticle(player.x + player.width/2, platform.y, particleColor, 20, 4, 1.5);

                        if(selectedMode === 'timeAttack') {
                            score += 10 * (scoreMultiplier.active ? 2 : 1);
                        }
                    }
                });
            }

            updateGameObjects();
            generatePlatforms();
            spawnBombs();
            spawnPowerups();
            updateParticles();

            if (player.y - cameraY > canvasHeight) { gameOver = true; playSound('gameOver', 'C2'); }
            if (checkBombCollisions()) { gameOver = true; playSound('gameOver', 'C2'); }
            if (screenShake.duration > 0) {
                screenShake.duration--;
                if (screenShake.duration <= 0) screenShake.intensity = 0;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            ctx.save();
            const shakeX = (Math.random() - 0.5) * screenShake.intensity;
            const shakeY = (Math.random() - 0.5) * screenShake.intensity;
            ctx.translate(shakeX, -cameraY + shakeY);
            
            drawBackground();
            drawParticles();
            platforms.forEach(p => drawPlatform(p));
            powerups.forEach(p => drawPowerup(p));
            bombs.forEach(b => drawBomb(b));
            drawPlayerTrail();
            drawPlayer();
            
            ctx.restore();
        }

        // --- Drawing Functions ---
        function drawPlayer() {
            const squashHeight = player.height * player.squash;
            const squashWidth = player.width / player.squash;
            ctx.shadowBlur = 30;
            ctx.shadowColor = player.hasShield ? "#00c6ff" : "#ffffff";

            ctx.save();
            if (player.hasShield) {
                ctx.fillStyle = "rgba(0, 198, 255, 0.3)";
                ctx.beginPath();
                const pulse = 1 + Math.sin(Date.now() / 200) * 0.15;
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.shieldRadius * pulse, 0, 2 * Math.PI);
                ctx.fill();
            }

ctx.fillStyle = "#ffffff";
            ctx.shadowBlur = 40;
            ctx.shadowColor = player.hasShield ? "#00c6ff" : "#ffffff";
            ctx.beginPath();
            ctx.ellipse(player.x + player.width / 2, player.y + player.height / 2, squashWidth / 2, squashHeight / 2, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawPlatform(platform) {
            ctx.save();
            let gradient = ctx.createLinearGradient(platform.x, platform.y, platform.x + platform.width, platform.y);
            let shadowColor;
            
            if (platform.type === 'phasing') {
                const phaseAlpha = Math.sin(platform.phaseTimer * Math.PI / platform.phaseDuration) * 0.8 + 0.2;
                ctx.globalAlpha = platform.isVisible ? phaseAlpha : 0;
                gradient.addColorStop(0, "#e040fb");
                gradient.addColorStop(0.5, "#9c27b0");
                gradient.addColorStop(1, "#7c4dff");
                shadowColor = "#e040fb";
            } else {
                switch (platform.type) {
                    case "moving":
                        shadowColor = "#00c6ff";
                        gradient.addColorStop(0, "#00c6ff");
                        gradient.addColorStop(0.5, "#0091ea");
                        gradient.addColorStop(1, "#0072ff");
                        break;
                    case "bouncy":
                        shadowColor = "#a8e063";
                        gradient.addColorStop(0, "#a8e063");
                        gradient.addColorStop(0.5, "#78c850");
                        gradient.addColorStop(1, "#56ab2f");
                        break;
                    case "breaking":
                        if (platform.isBreaking) ctx.globalAlpha = Math.max(0, platform.breakTimer / 45);
                        shadowColor = "#ff416c";
                        gradient.addColorStop(0, "#ff416c");
                        gradient.addColorStop(0.5, "#ff1744");
                        gradient.addColorStop(1, "#ff4b2b");
                        break;
                    default:
                        shadowColor = "#8e2de2";
                        gradient.addColorStop(0, "#8e2de2");
                        gradient.addColorStop(0.5, "#7c1dc6");
                        gradient.addColorStop(1, "#4a00e0");
                        break;
                }
            }

            // Add platform glow effect
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 15;
            ctx.fillStyle = gradient;
            
            // Draw platform with rounded corners
            const radius = 8;
            ctx.beginPath();
            ctx.moveTo(platform.x + radius, platform.y);
            ctx.lineTo(platform.x + platform.width - radius, platform.y);
            ctx.quadraticCurveTo(platform.x + platform.width, platform.y, platform.x + platform.width, platform.y + radius);
            ctx.lineTo(platform.x + platform.width, platform.y + platform.height - radius);
            ctx.quadraticCurveTo(platform.x + platform.width, platform.y + platform.height, platform.x + platform.width - radius, platform.y + platform.height);
            ctx.lineTo(platform.x + radius, platform.y + platform.height);
            ctx.quadraticCurveTo(platform.x, platform.y + platform.height, platform.x, platform.y + platform.height - radius);
            ctx.lineTo(platform.x, platform.y + radius);
            ctx.quadraticCurveTo(platform.x, platform.y, platform.x + radius, platform.y);
            ctx.closePath();
            ctx.fill();

            // Add shine effect
            const shine = ctx.createLinearGradient(platform.x, platform.y, platform.x, platform.y + platform.height);
            shine.addColorStop(0, "rgba(255,255,255,0.1)");
            shine.addColorStop(0.5, "rgba(255,255,255,0)");
            ctx.fillStyle = shine;
            ctx.fill();
            
            ctx.restore();
        }

        function drawPlayerTrail() {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < player.trail.length; i++) {
                const t = player.trail[i];
                const progress = i / player.trail.length;
                const opacity = progress * 0.6;
                const size = progress * (t.width / 2);
                const gradient = ctx.createRadialGradient(
                    t.x + player.width/2, t.y + player.height/2, 0,
                    t.x + player.width/2, t.y + player.height/2, size
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(t.x + player.width/2, t.y + player.height/2, size, 0, 2 * Math.PI);
                ctx.fill();
            }
            ctx.restore();
        }
        
        function drawPowerup(powerup) {
            ctx.save();
            ctx.shadowBlur = 20;
            const angle = Date.now() / 500;
            const yOffset = Math.sin(angle) * 5;
            ctx.font = '30px Cairo';
            ctx.textAlign = 'center';
            let emoji, color;
            if (powerup.type === 'shield') { emoji = '🛡️'; color = '#00c6ff'; } 
            else if (powerup.type === 'superJump') { emoji = '🚀'; color = '#f7b733'; }
            else if (powerup.type === 'time') { emoji = '⏱️'; color = '#ffffff'; }
            else if (powerup.type === 'scoreMultiplier') { emoji = '💎'; color = '#ffd700'; }
            ctx.shadowColor = color;
            ctx.fillText(emoji, powerup.x + powerup.width/2, powerup.y + yOffset + powerup.height);
            ctx.restore();
        }

        function drawBomb(bomb) {
            ctx.save();
            ctx.translate(bomb.x + bomb.width/2, bomb.y + bomb.height/2);
            ctx.rotate(bomb.angle);
            ctx.font = '30px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('💣', 0, 0);
            ctx.restore();
        }

        function createParticle(x, y, color, count, speed = 1, sizeMult = 1) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.random() * Math.PI * 2);
                const velocity = (Math.random() * speed * 2) + speed;
                particles.push({
                    x: x,
                    y: y,
                    size: (Math.random() * 2.5 + 1) * sizeMult,
                    speedX: Math.cos(angle) * velocity,
                    speedY: Math.sin(angle) * velocity,
                    color: color,
                    life: 80 + Math.random() * 40,
                    maxLife: 80 + Math.random() * 40,
                    gravity: 0.05,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
        }

        function updateParticles() {
            if (player.dy > 0.1) {
                createParticle(player.x + player.width / 2, player.y + player.height, "rgba(255,255,255,0.4)", 1, 0.3, 0.8);
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.speedX;
                p.y += p.speedY;
                p.life--;
                p.speedY += p.gravity;
                p.size *= 0.98;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // --- Game Logic ---
        function createPlatform(x, y) {
            const rand = Math.random();
            const mode = modeSettings[selectedMode];
            const levelProgress = Math.min(score / 5000, 1);
            let type = 'normal';

            const isMobile = window.innerWidth < 600;
            // حجم المنصة يتغير حسب الجهاز، مع حد أدنى ثابت
            let baseWidth = isMobile ? 90 : 120;
            baseWidth += mode.platWidthMod;
            baseWidth -= 40 * levelProgress;
            // حد أدنى ثابت مهما كان التقدم
            const minWidth = isMobile ? 60 : 80;
            baseWidth = Math.max(minWidth, baseWidth);

            const movingChance = 0.22 + (0.15 * levelProgress); 
            const bouncyChance = movingChance + 0.16 + (0.1 * levelProgress);
            const breakingChance = bouncyChance + 0.17 + (0.1 * levelProgress); 
            const phasingChance = breakingChance + 0.15 + (0.1 * levelProgress);

            if (currentLevelIndex >= 1 && rand < movingChance) type = 'moving';
            else if (currentLevelIndex >= 2 && rand < bouncyChance) type = 'bouncy';
            else if (currentLevelIndex >= 3 && rand < breakingChance) type = 'breaking';
            else if (currentLevelIndex >= 4 && rand < phasingChance) type = 'phasing';
            
            let platform = {
                x, y, 
                width: baseWidth,
                height: isMobile ? 16 : 20,
                type,
                dx: type === 'moving' ? ((Math.random() * 0.3) + (dynamicLevels[currentLevelIndex].platformSpeed * mode.speedMod * 0.5)) * (Math.random() < 0.5 ? 1 : -1) : 0,
                isBreaking: false, breakTimer: 45, hasPowerup: false
            };
            
            if (type === 'phasing') {
                platform.phaseDuration = 120 + Math.random() * 60;
                platform.phaseTimer = Math.random() * platform.phaseDuration;
                platform.isVisible = true;
            }
            return platform;
        }

        function updateGameObjects() {
            for (let i = platforms.length - 1; i >= 0; i--) {
                const p = platforms[i];
                if (p.type === 'moving') {
                    p.x += p.dx * dynamicSpeedMultiplier;
                    if (p.x <= 0 || p.x + p.width >= canvasWidth) {
                        p.dx *= -1;
                    }
                }
                if (p.isBreaking) {
                    p.breakTimer--;
                    if (p.breakTimer <= 0) {
                        createParticle(p.x + p.width / 2, p.y, '#ff416c', 15, 2);
                        platforms.splice(i, 1);
                    }
                }
                if (p.type === 'phasing') {
                    p.phaseTimer++;
                    if (p.phaseTimer >= p.phaseDuration) {
                        p.phaseTimer = 0;
                        p.isVisible = !p.isVisible;
                        if (p.y > cameraY && p.y < cameraY + canvasHeight) {
                           playSound('phase', p.isVisible ? 'C5' : 'C4');
                        }
                    }
                }
            }

            bombs.forEach(bomb => { bomb.y += bomb.dy * dynamicSpeedMultiplier; bomb.angle += 0.05; });
            bombs = bombs.filter(bomb => bomb.y < cameraY + canvasHeight + 50);

            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.life--;
                if (checkCollision(player, p)) {
                    onCollectPowerup(p);
                    p.life = 0;
                }
                if (p.life <= 0) {
                    const platform = platforms.find(pl => pl.hasPowerup === p);
                    if (platform) platform.hasPowerup = false;
                    powerups.splice(i, 1);
                }
            }
        }

        function spawnPowerups() {
            const mode = modeSettings[selectedMode];
            // قلل معدل ظهور المكافآت بشكل عام
            if (Math.random() < mode.powerupRate * 0.4) { // تقليل معدل الظهور أكثر
                const availablePlatforms = platforms.filter(p => !p.hasPowerup && p.y < cameraY + canvasHeight && p.y > cameraY && p.type !== 'breaking' && p.type !== 'phasing');
                if (availablePlatforms.length > 0) {
                    const platform = availablePlatforms[Math.floor(Math.random() * availablePlatforms.length)];
                    let rand = Math.random();
                    let type;
                    // --- superJump logic ---
                    // تحديث نافذة النقاط إذا تجاوزناها
                    if (score - superJumpWindowStartScore >= SUPERJUMP_WINDOW) {
                        superJumpWindowStartScore += SUPERJUMP_WINDOW;
                        superJumpAppearancesInWindow = 0;
                    }
                    // superJump يظهر مرة أو مرتين فقط في كل نافذة نقاط
                    if (
                        superJumpAppearancesInWindow < SUPERJUMP_MAX_PER_WINDOW &&
                        score >= 200 && // لا تظهر في أول 200 نقطة
                        rand > 0.92 && // احتمال أقل (8%)
                        (score - superJumpWindowStartScore) > 100 // لا تظهر في أول 100 نقطة من النافذة
                    ) {
                        type = 'superJump';
                        superJumpAppearancesInWindow++;
                    } else {
                        // باقي المكافآت تظهر باحتمال أقل من السابق
                        if (selectedMode === 'timeAttack') {
                            // في طور الوقت فقط تظهر مكافأة الوقت
                            if (rand < 0.25) type = 'shield';
                            else if (rand < 0.5) type = 'scoreMultiplier';
                            else type = 'time';
                        } else {
                            if (rand < 0.33) type = 'shield';
                            else type = 'scoreMultiplier';
                        }
                    }
                    const newPowerup = { x:platform.x + platform.width / 2 - 12.5, y: platform.y - 30, width: 25, height: 25, type, life: 600 };
                    powerups.push(newPowerup);
                    platform.hasPowerup = newPowerup;
                }
            }
        }

        function spawnBombs() {
            const mode = modeSettings[selectedMode];
            const isMobile = window.innerWidth < 600;
            let bombRate = mode.bombSpawnRate;
            // في وضع الجنون على الجوال: زيادة معدل القنابل قليلاً
            if (selectedMode === 'frenzy' && isMobile) bombRate *= 1.5;
            const difficulty = Math.min(score / 8000, 1);
            const spawnThreshold = Math.max(200, (selectedMode === 'frenzy' ? 220 : 500) * (1 - difficulty * 0.4));
            if (bombRate > 0 && (score - lastBombSpawnScore > spawnThreshold)) {
                if (Math.random() < bombRate + (0.01 * difficulty)) { 
                    bombs.push({ 
                        x: Math.random() * canvasWidth, 
                        y: cameraY - 50, 
                        width: isMobile ? 24 : 30, 
                        height: isMobile ? 24 : 30, 
                        dy: 2 + Math.random() * 2 + (1.5 * difficulty),
                        angle: 0 
                    });
                    lastBombSpawnScore = score;
                    playSound('rumble', 'G2');
                }
            }
        }

        function generatePlatforms() {
            let topPlatformY = platforms.length > 0 ? platforms.reduce((min, p) => p.y < min ? p.y : min, platforms[0].y) : canvasHeight;
            if (topPlatformY > cameraY - 100) {
                const mode = modeSettings[selectedMode];
                let newY = topPlatformY - (95 + Math.random() * 50);
                let newX = Math.random() * (canvasWidth - (120 + mode.platWidthMod));
                platforms.push(createPlatform(newX, newY));
            }
            platforms = platforms.filter(p => p.y < cameraY + canvasHeight + 100);
        }

        function checkCollision(objA, objB) { return objA.x < objB.x + objB.width && objA.x + objA.width > objB.x && objA.y < objB.y + objB.height && objA.y + objA.height > objB.y; }
        
        function checkBombCollisions() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                if (checkCollision(player, bombs[i])) {
                    if (player.hasShield) {
                        player.hasShield = false;
                        bombs.splice(i, 1);
                        createParticle(player.x + player.width/2, player.y + player.height/2, '#00c6ff', 100, 9);
                        triggerScreenShake(8, 20);
                        playSound('shieldDeflect', 'G4');
                        return false;
                    } else {
                        const shakeIntensity = selectedMode === 'frenzy' ? 30 : 20;
                        triggerScreenShake(shakeIntensity, 40);
                        createParticle(player.x + player.width/2, player.y + player.height/2, '#ff3c00', 200, 15);
                        return true;
                    }
                }
            }
            return false;
        }

        function triggerScreenShake(intensity, duration) { screenShake.intensity = Math.max(screenShake.intensity, intensity); screenShake.duration = Math.max(screenShake.duration, duration); }
        
        function drawBackground() {
            const level = dynamicLevels[currentLevelIndex];
            const glowColor = level.glow;
            let grad = ctx.createRadialGradient(player.x + player.width/2, player.y, 50, canvasWidth/2, player.y, canvasWidth);
            grad.addColorStop(0, `${glowColor}33`);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.fillRect(0, cameraY, canvasWidth, canvasHeight);
        }

        function onCollectPowerup(powerup) {
            if (powerup.type === 'shield') {
                player.hasShield = true;
                createParticle(powerup.x, powerup.y, '#00c6ff', 50, 8, 2);
            } else if (powerup.type === 'superJump') {
                player.dy = -player.jumpPower * 2.2;
                createParticle(powerup.x, powerup.y, '#f7b733', 50, 8, 2);
                playSound('superJump', 'C5');
            } else if (powerup.type === 'time') {
                gameTimer = Math.min(60, gameTimer + 5);
                createParticle(powerup.x, powerup.y, '#ffffff', 50, 8, 2);
            } else if (powerup.type === 'scoreMultiplier') {
                scoreMultiplier.active = true;
                scoreMultiplier.timer = 5;
                createParticle(powerup.x, powerup.y, '#ffd700', 50, 8, 2);
                playSound('scoreBoost', 'E6');
            }
            createParticle(powerup.x, powerup.y, '#FFD700', 100, 10, 3);
            playSound('powerup', 'C6');
            score += 50 * (scoreMultiplier.active ? 2 : 1);
            updateScoreUI();
        }

        function generateNextLevel(lastLevel) {
            // زيادة المسافة بين المستويات بشكل كبير
            const nextScore = lastLevel.score + 15000 + (dynamicLevels.length - baseLevels.length) * 7000;
            
            // تحسين معدل زيادة السرعة ليكون أكثر تدرجاً
            const newSpeed = lastLevel.platformSpeed + (0.3 + Math.random() * 0.2);
            
            // تحسين نظام الألوان للمستويات المتقدمة
            const hue1 = Math.random() * 360;
            const hue2 = (hue1 + 40 + Math.random() * 80) % 360;
            const bg1 = `hsl(${hue1}, 70%, 20%)`;
            const bg2 = `hsl(${hue1}, 60%, 10%)`;
            const glow = `hsl(${hue2}, 90%, 60%)`;

            return { 
                score: nextScore, 
                name: `البعد ${dynamicLevels.length + 1}`, 
                bg: [bg1, bg2], 
                glow: glow, 
                platformSpeed: Math.min(newSpeed, 6.0) // وضع حد أقصى للسرعة
            };
        }

        function enhancePlatformGeneration() {
            // Increase platform generation rate
            if (Math.random() < 0.8) {
                generatePlatforms();
            }
        }

        // **FIXED**: Rewrote the level update logic to be safer and prevent crashes.
        function updateLevel(force = false) {
            if (force) {
                // On game start, just set the styles for the initial level
                const initialLevel = dynamicLevels[currentLevelIndex];
                if (initialLevel) {
                    document.documentElement.style.setProperty("--bg-grad-1", initialLevel.bg[0]);
                    document.documentElement.style.setProperty("--bg-grad-2", initialLevel.bg[1]);
                    document.documentElement.style.setProperty("--glow-color", initialLevel.glow);
                }
                return;
            }

            // Always ensure there's a next level to aim for.
            if (currentLevelIndex === dynamicLevels.length - 1) {
                dynamicLevels.push(generateNextLevel(dynamicLevels[currentLevelIndex]));
            }

            const nextLevelDef = dynamicLevels[currentLevelIndex + 1];

            // Check if we've met the score requirement for the next level
            if (nextLevelDef && score >= nextLevelDef.score) {
                currentLevelIndex++;
                const newLevel = dynamicLevels[currentLevelIndex];

                // Update UI and effects for leveling up
                levelDisplay.textContent = newLevel.name;
                levelDisplay.style.opacity = 1;
                createParticle(canvasWidth / 2, cameraY + canvasHeight / 2, newLevel.glow, 200, 15, 4);
                setTimeout(() => { levelDisplay.style.opacity = 0; }, 3000);
                playSound('levelUp', ['C5', 'E5', 'G5']);

                // Update the visual theme
                document.documentElement.style.setProperty("--bg-grad-1", newLevel.bg[0]);
                document.documentElement.style.setProperty("--bg-grad-2", newLevel.bg[1]);
                document.documentElement.style.setProperty("--glow-color", newLevel.glow);
            }
        }

        function updateScoreUI() {
            scoreDisplay.textContent = `النتيجة: ${score}`;
            highScoreDisplay.textContent = `أعلى نتيجة: ${highScore}`;
            if (scoreMultiplier.active) {
                scoreMultiplierDisplay.textContent = `💎 x2 (${Math.ceil(scoreMultiplier.timer)}s)`;
                scoreMultiplierDisplay.classList.remove('hidden');
                scoreMultiplierDisplay.style.transform = 'scale(1.1)';
            } else {
                scoreMultiplierDisplay.classList.add('hidden');
                scoreMultiplierDisplay.style.transform = 'scale(1)';
            }
            if(selectedMode === 'timeAttack') {
                timerDisplay.textContent = `الوقت: ${Math.ceil(gameTimer)}`;
            }
            // وميض عند القفزات المثالية
    if (perfectStreak > 1) {
        scoreDisplay.style.color = '#00ffea';
        scoreDisplay.style.textShadow = '0 0 20px #00ffea, 0 0 40px #00ffea';
        setTimeout(() => {
            scoreDisplay.style.color = '';
            scoreDisplay.style.textShadow = '';
        }, 400);
    }
        }
        function showGameOverMenu() {
            finalScoreDisplay.textContent = `نتيجتك: ${score}`;
            if (score > highScore) { highScore = score; localStorage.setItem(`luminousLeapHighScore_${selectedMode}`, highScore); finalScoreDisplay.innerHTML += ' <br><strong>رقم قياسي جديد!</strong>'; }
            updateScoreUI(); gameOverMenu.style.display = 'flex';
        }
        
        // --- Event Listeners ---
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            player.x = e.clientX - rect.left - player.width / 2;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvasWidth) player.x = canvasWidth - player.width;
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                player.x = e.touches[0].clientX - rect.left - player.width / 2;
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > canvasWidth) player.x = canvasWidth - player.width;
            }
        }
        
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                initAudio();
                playSound('menuSelect', 'C5');
                selectedMode = button.dataset.mode;
                mainMenu.classList.add('hidden');
                scoreContainer.classList.remove('hidden');
                canvas.classList.remove('hidden');
                resizeCanvas();
                startGame();
            });
        });

        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('mousedown', (e) => { canvas.requestPointerLock && canvas.requestPointerLock(); });
        restartButton.addEventListener('click', () => { gameOverMenu.style.display = 'none'; startGame(); });
        mainMenuButton.addEventListener('click', () => {
            gameOverMenu.style.display = 'none';
            scoreContainer.classList.add('hidden');
            canvas.classList.add('hidden');
            mainMenu.classList.remove('hidden');
        });
        
        resizeCanvas();
    </script>
</body>
</html>
